/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src */ \"./src/index.js\");\n\r\n\r\nlet canvas = document.createElement(\"canvas\");\r\n\r\ndocument.body.appendChild(canvas);\r\n\r\nlet scene = new _src__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]({ el: canvas });\r\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/eventemitter2/lib/eventemitter2.js":
/*!*********************************************************!*\
  !*** ./node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if(!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason){\n      throw Error('Invalid \"' + option + '\" option value' + (reason? '. Reason: '+ reason : ''))\n    }\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('Promise option must be a constructor');\n    }\n    return value;\n  }\n\n  function functionReducer(value, reject) {\n    if (typeof value !== 'function') {\n      reject('Promise option must be a function');\n    }\n    return value;\n  }\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscribeClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscribeClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscribeClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name !== undefined) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          tree._listeners.push(listener);\n\n          if (\n            !tree._listeners.warned &&\n            this._maxListeners > 0 &&\n            tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    return this._once(event, fn, false);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\n    return this._once(event, fn, true);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend) {\n    this._many(event, 1, fn, prepend);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    return this._many(event, ttl, fn, false);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\n    return this._many(event, ttl, fn, true);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this._on(event, listener, prepend);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    var al = arguments.length;\n    var args,l,i,j;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n      if (al > 3) {\n        args = new Array(al);\n        for (j = 0; j < al; j++) args[j] = arguments[j];\n      }\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n    }\n\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var args,l,i,j;\n    var handler;\n\n    if (this._all) {\n      if (al > 3) {\n        args = new Array(al);\n        for (j = 1; j < al; j++) args[j] = arguments[j];\n      }\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, args));\n        }\n      }\n    }\n\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n    return this._on(type, listener, false);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener) {\n    return this._on(type, listener, true);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener)\n       this.emit('newListener', type, listener);\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    function recursivelyGarbageCollect(root) {\n      if (root === undefined) {\n        return;\n      }\n      var keys = Object.keys(root);\n      for (var i in keys) {\n        var key = keys[i];\n        var obj = root[key];\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\n          continue;\n        if (Object.keys(obj).length > 0) {\n          recursivelyGarbageCollect(root[key]);\n        }\n        if (Object.keys(obj).length === 0) {\n          delete root[key];\n        }\n      }\n    }\n    recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.eventNames = function(){\n    return Object.keys(this._events);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function(){\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      }\n  });\n\n  if (true) {\n     // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var _global; }\n}();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/eventemitter2/lib/eventemitter2.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/element.js":
/*!************************!*\
  !*** ./src/element.js ***!
  \************************/
/*! exports provided: Element */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element; });\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter2 */ \"./node_modules/eventemitter2/lib/eventemitter2.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n/**\r\n * @typedef Rect\r\n * @property {number} x\r\n * @property {number} y\r\n * @property {number} width\r\n * @property {number} height\r\n */\r\n\r\nclass Element extends eventemitter2__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter2\"] {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.visible = true;\r\n\t\tthis.id = props.id || \"\";\r\n\t\tthis.x = props.x || 0;\r\n\t\tthis.y = props.y || 0;\r\n\t\tthis.width = props.width || 0;\r\n\t\tthis.height = props.height || 0;\r\n\t}\r\n\r\n\tupdateAnimation() {}\r\n\r\n\t/**\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @returns {boolean}\r\n\t */\r\n\trender(ctx) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @returns {Element}\r\n\t */\r\n\thitTest(x, y, ctx) {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** @returns {Rect} */\r\n\tgetBound() {\r\n\t\treturn { x: this.x, y: this.y, width: this.width, height: this.height };\r\n\t}\r\n\r\n\tcentralize(width, height) {\r\n\t\tlet b = this.getBound();\r\n\t\tthis.x = (width - b.width) / 2;\r\n\t\tthis.y = (height - b.height) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Element} item\r\n\t * @returns {boolean}\r\n\t */\r\n\thaveIntersection(item) {\r\n\t\tlet a = this.getBound();\r\n\t\tlet b = item.getBound();\r\n\t\tvar a1x = a.x;\r\n\t\tvar a2x = a.x + a.width;\r\n\t\tvar a1y = a.y;\r\n\t\tvar a2y = a.y + a.height;\r\n\t\tvar b1x = b.x;\r\n\t\tvar b2x = b.x + b.width;\r\n\t\tvar b1y = b.y;\r\n\t\tvar b2y = b.y + b.height;\r\n\t\treturn a1x <= b2x && a2x >= b1x && a1y <= b2y && a2y >= b1y;\r\n\t}\r\n\r\n\tmakeDraggable(disableX, disableY) {\r\n\t\tthis.on(\"mousedown\", (e) => {\r\n\t\t\tthis._on_dragging = true;\r\n\t\t\tif (!disableX) {\r\n\t\t\t\tthis._originalX = this.x;\r\n\t\t\t\tthis._startDraggingX = e.x;\r\n\t\t\t}\r\n\t\t\tif (!disableY) {\r\n\t\t\t\tthis._originalY = this.y;\r\n\t\t\t\tthis._startDraggingY = e.y;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.on(\"mousedrag\", (e) => {\r\n\t\t\tif (!this._on_dragging) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!disableX) {\r\n\t\t\t\tthis.x = this._originalX + e.x - this._startDraggingX;\r\n\t\t\t}\r\n\t\t\tif (!disableY) {\r\n\t\t\t\tthis.y = this._originalY + e.y - this._startDraggingY;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.on(\"mousedragend\", (e) => {\r\n\t\t\tthis._on_dragging = false;\r\n\t\t});\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/element.js?");

/***/ }),

/***/ "./src/event.js":
/*!**********************!*\
  !*** ./src/event.js ***!
  \**********************/
/*! exports provided: Event, EventDelegate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Event\", function() { return Event; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDelegate\", function() { return EventDelegate; });\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter2 */ \"./node_modules/eventemitter2/lib/eventemitter2.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/helpers/index.js\");\n\r\n\r\n\r\n/**\r\n * @typedef Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n\r\nclass Event {\r\n\t/**\r\n\t * @param {string} name\r\n\t * @param {number} [x]\r\n\t * @param {number} [y]\r\n\t */\r\n\tconstructor(name, x, y) {\r\n\t\tthis.name = name;\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.wheelDeltaX = 0;\r\n\t\tthis.wheelDeltaY = 0;\r\n\t\tthis.keyCode = 0;\r\n\t\tthis.keyName = 0;\r\n\t\t/** @type {Point[]} */\r\n\t\tthis.touches = [];\r\n\t}\r\n\r\n\tclone() {\r\n\t\tlet ne = new Event(this.name, this.x, this.y);\r\n\t\tne.wheelDeltaX = this.wheelDeltaX;\r\n\t\tne.wheelDeltaY = this.wheelDeltaY;\r\n\t\tne.keyCode = this.keyCode;\r\n\t\tne.keyName = this.keyName;\r\n\t\tfor (let t of this.touches) {\r\n\t\t\tne.touches.push(t);\r\n\t\t}\r\n\t\treturn ne;\r\n\t}\r\n}\r\n\r\nclass EventDelegate extends eventemitter2__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter2\"] {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.watchMouseDrag = false;\r\n\t\tthis.w = props.w || 800;\r\n\t\tthis.h = props.h || 600;\r\n\t\t/** @type {HTMLCanvasElement} */\r\n\t\tthis.el = props.el;\r\n\t\tthis.el.onmousedown = this.onMouseDown.bind(this);\r\n\t\tthis.el.onmouseup = this.onMouseUp.bind(this);\r\n\t\tthis.el.onmousemove = this.onMouseMove.bind(this);\r\n\t\tthis.el.onmouseout = this.onMouseOut.bind(this);\r\n\t\tthis.el.ontouchstart = this.onTouchStart.bind(this);\r\n\t\tthis.el.ontouchmove = this.onTouchMove.bind(this);\r\n\t\tthis.el.ontouchend = this.onTouchEnd.bind(this);\r\n\t\tthis.el.onwheel = this.onMouseWheel.bind(this);\r\n\r\n\t\tthis.ctx = this.el.getContext(\"2d\");\r\n\t\tthis.ctx.imageSmoothingEnabled = false;\r\n\r\n\t\tthis.resize(this.w, this.h);\r\n\r\n\t\tthis.offsetX = 0;\r\n\t\tthis.offsetY = 0;\r\n\t\tthis.calcOffset();\r\n\t}\r\n\r\n\tresize(w, h) {\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\r\n\t\tthis.el.width = w;\r\n\t\tthis.el.height = h;\r\n\t\tthis.el.style.width = w + \"px\";\r\n\t\tthis.el.style.height = h + \"px\";\r\n\r\n\t\tif (window.devicePixelRatio) {\r\n\t\t\tthis.el.width *= window.devicePixelRatio;\r\n\t\t\tthis.el.height *= window.devicePixelRatio;\r\n\t\t\tthis.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\r\n\t\t}\r\n\t}\r\n\r\n\tcalcOffset() {\r\n\t\tlet bbox = this.el.getBoundingClientRect();\r\n\t\tthis.offsetX = bbox.left * (this.el.width / bbox.width);\r\n\t\tthis.offsetY = bbox.top * (this.el.height / bbox.height);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {Point}\r\n\t */\r\n\ttranslatePoint(x, y) {\r\n\t\treturn {\r\n\t\t\tx: x - this.offsetX,\r\n\t\t\ty: y - this.offsetY,\r\n\t\t};\r\n\t}\r\n\r\n\t/** @param {MouseEvent} e */\r\n\tonMouseDown(e) {\r\n\t\tthis.watchMouseDrag = true;\r\n\t\tlet p = this.translatePoint(e.clientX, e.clientY);\r\n\t\tlet event = new Event(\"mousedown\", p.x, p.y);\r\n\t\tthis.triggerMouseDown(event);\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {MouseEvent} e */\r\n\tonMouseUp(e) {\r\n\t\tthis.watchMouseDrag = false;\r\n\t\tlet p = this.translatePoint(e.clientX, e.clientY);\r\n\t\tlet event = new Event(\"mouseup\", p.x, p.y);\r\n\t\tthis.triggerMouseUp(event);\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {MouseEvent} e */\r\n\tonMouseOut(e) {\r\n\t\tif (this.watchMouseDrag) {\r\n\t\t\tthis.onMouseUp(e);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @param {MouseEvent} e */\r\n\tonMouseMove(e) {\r\n\t\tif (this.watchMouseDrag) {\r\n\t\t\tlet p = this.translatePoint(e.clientX, e.clientY);\r\n\t\t\tlet event = new Event(\"mousemove\", p.x, p.y);\r\n\t\t\tthis.triggerMouseMove(event);\r\n\t\t}\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {TouchEvent} e */\r\n\tonTouchStart(e) {\r\n\t\tif (e.touches.length === 1) {\r\n\t\t\tlet event = new MouseEvent(\"mousedown\", {\r\n\t\t\t\tbubbles: true,\r\n\t\t\t\tcancelable: true,\r\n\t\t\t\tview: window,\r\n\t\t\t\tclientX: e.touches[0].pageX,\r\n\t\t\t\tclientY: e.touches[0].pageY,\r\n\t\t\t});\r\n\t\t\tthis.onMouseDown(event);\r\n\t\t}\r\n\r\n\t\tlet event = new Event(\"touchstart\");\r\n\t\tlet touches = [];\r\n\t\tfor (let t of e.touches) {\r\n\t\t\tlet touch = this.translatePoint(t.pageX, t.pageY);\r\n\t\t\ttouches.push(touch);\r\n\t\t}\r\n\t\tevent.touches = touches;\r\n\t\tthis.emit(\"touchstart\", event);\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {TouchEvent} e */\r\n\tonTouchMove(e) {\r\n\t\tif (e.touches.length === 1) {\r\n\t\t\tlet event = new MouseEvent(\"mousemove\", {\r\n\t\t\t\tbubbles: true,\r\n\t\t\t\tcancelable: true,\r\n\t\t\t\tview: window,\r\n\t\t\t\tclientX: e.touches[0].pageX,\r\n\t\t\t\tclientY: e.touches[0].pageY,\r\n\t\t\t});\r\n\t\t\tthis.onMouseMove(event);\r\n\t\t}\r\n\r\n\t\tlet event = new Event(\"touchmove\");\r\n\t\tlet touches = [];\r\n\t\tfor (let t of e.touches) {\r\n\t\t\tlet touch = this.translatePoint(t.pageX, t.pageY);\r\n\t\t\ttouches.push(touch);\r\n\t\t}\r\n\t\tevent.touches = touches;\r\n\t\tthis.emit(\"touchmove\", event);\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {TouchEvent} e */\r\n\tonTouchEnd(e) {\r\n\t\tif (e.touches.length === 1) {\r\n\t\t\tlet event = new MouseEvent(\"mouseup\", {\r\n\t\t\t\tbubbles: true,\r\n\t\t\t\tcancelable: true,\r\n\t\t\t\tview: window,\r\n\t\t\t\tclientX: e.touches[0].pageX,\r\n\t\t\t\tclientY: e.touches[0].pageY,\r\n\t\t\t});\r\n\t\t\tthis.onMouseUp(event);\r\n\t\t}\r\n\r\n\t\tlet event = new Event(\"touchend\");\r\n\t\tlet touches = [];\r\n\t\tfor (let t of e.touches) {\r\n\t\t\tlet touch = this.translatePoint(t.pageX, t.pageY);\r\n\t\t\ttouches.push(touch);\r\n\t\t}\r\n\t\tevent.touches = touches;\r\n\t\tthis.emit(\"touchend\", event);\r\n\t\te.preventDefault();\r\n\t}\r\n\r\n\t/** @param {WheelEvent} e */\r\n\tonMouseWheel(e) {\r\n\t\tlet p = this.translatePoint(e.clientY, e.clientY);\r\n\t\tlet event = new Event(\"mousewheel\", p.x, p.y);\r\n\t\t// @ts-ignore\r\n\t\tif (e.wheelDeltaY) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tevent.wheelDeltaY = e.wheelDeltaY || 0;\r\n\t\t\t// @ts-ignore\r\n\t\t\tevent.wheelDeltaX = e.wheelDeltaX || 0;\r\n\t\t\t// @ts-ignore\r\n\t\t} else if (e.wheelDelta) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tevent.wheelDeltaY = e.wheelDelta;\r\n\t\t\tevent.wheelDeltaX = 0;\r\n\t\t} else {\r\n\t\t\tevent.wheelDeltaY = (-120 * e.detail) / 3;\r\n\t\t\tevent.wheelDeltaX = 0;\r\n\t\t}\r\n\t\tthis.triggerMouseWheel(event);\r\n\t\te.preventDefault();\r\n\r\n\t\t_helpers__WEBPACK_IMPORTED_MODULE_1__[\"NotificationCenter\"].emit(\"render\");\r\n\t}\r\n\r\n\t//============================\r\n\r\n\t/** @param {Event} e */\r\n\ttriggerMouseDown(e) {}\r\n\t/** @param {Event} e */\r\n\ttriggerMouseUp(e) {}\r\n\t/** @param {Event} e */\r\n\ttriggerMouseMove(e) {}\r\n\t/** @param {Event} e */\r\n\ttriggerMouseWheel(e) {}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/event.js?");

/***/ }),

/***/ "./src/helpers/arraymgr.js":
/*!*********************************!*\
  !*** ./src/helpers/arraymgr.js ***!
  \*********************************/
/*! exports provided: ArrayMgr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayMgr\", function() { return ArrayMgr; });\nclass ArrayMgr {\r\n\tconstructor() {\r\n\t\tthis.items = [];\r\n\t}\r\n\r\n\tadd(item) {}\r\n\r\n\trm(item) {}\r\n\r\n\tmove(item, index) {}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/helpers/arraymgr.js?");

/***/ }),

/***/ "./src/helpers/index.js":
/*!******************************!*\
  !*** ./src/helpers/index.js ***!
  \******************************/
/*! exports provided: ArrayMgr, NotificationCenter, colorOne, colorTwo, colorThree, isPointInRect, random, searchItemInGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorOne\", function() { return colorOne; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorTwo\", function() { return colorTwo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorThree\", function() { return colorThree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPointInRect\", function() { return isPointInRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"searchItemInGroup\", function() { return searchItemInGroup; });\n/* harmony import */ var _arraymgr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arraymgr */ \"./src/helpers/arraymgr.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ArrayMgr\", function() { return _arraymgr__WEBPACK_IMPORTED_MODULE_0__[\"ArrayMgr\"]; });\n\n/* harmony import */ var _notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notification */ \"./src/helpers/notification.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NotificationCenter\", function() { return _notification__WEBPACK_IMPORTED_MODULE_1__[\"NotificationCenter\"]; });\n\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../element */ \"./src/element.js\");\n\r\n\r\n\r\n\r\n\r\nlet lastTime = 0;\r\nvar vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\r\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n\twindow.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\r\n\twindow.cancelAnimationFrame =\r\n\t\twindow[vendors[x] + \"CancelAnimationFrame\"] ||\r\n\t\twindow[vendors[x] + \"CancelRequestAnimationFrame\"];\r\n}\r\n\r\nif (window.requestAnimationFrame === undefined) {\r\n\twindow.requestAnimationFrame = function (callback) {\r\n\t\tvar currTime = Date.now(),\r\n\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n\t\tvar id = window.setTimeout(function () {\r\n\t\t\tcallback(currTime + timeToCall);\r\n\t\t}, timeToCall);\r\n\t\tlastTime = currTime + timeToCall;\r\n\t\treturn id;\r\n\t};\r\n}\r\n\r\nif (window.cancelAnimationFrame === undefined) {\r\n\twindow.cancelAnimationFrame = function (id) {\r\n\t\tclearTimeout(id);\r\n\t};\r\n}\r\n\r\nlet colorOne = \"rgb(50,50,50)\";\r\nlet colorTwo = \"white\";\r\nlet colorThree = \"#eaeaea\";\r\n\r\n/**\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} x1\r\n * @param {number} y1\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {boolean}\r\n */\r\nfunction isPointInRect(x, y, x1, y1, width, height) {\r\n\treturn x >= x1 && x <= x1 + width && y >= y1 && y <= y1 + height;\r\n}\r\n\r\n/**\r\n * @param {number} from\r\n * @param {number} to\r\n * @param {boolean} no_floor\r\n */\r\nfunction random(from, to, no_floor) {\r\n\tif (Array.isArray(from)) {\r\n\t\treturn from[Math.floor(Math.random() * from.length)];\r\n\t}\r\n\tvar _from = from == null ? 0 : from,\r\n\t\t_to = to == null ? 0 : to;\r\n\tif (to < from) {\r\n\t\t_from = to;\r\n\t\t_to = from;\r\n\t} else if (to == from) {\r\n\t\t_to = _from + 10;\r\n\t}\r\n\tif (no_floor) {\r\n\t\treturn Math.random() * (_to - _from) + _from;\r\n\t} else {\r\n\t\treturn Math.floor(Math.random() * (_to - _from) + _from);\r\n\t}\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} group\r\n * @param {Element} item\r\n * @return {import(\"../event\").Point}\r\n */\r\nfunction searchItemInGroup(group, item) {\r\n\tvar found = false;\r\n\tvar pos = {\r\n\t\tx: 0,\r\n\t\ty: 0,\r\n\t};\r\n\r\n\tif (group.name === \"Scrollbase\") {\r\n\t\tpos.x += group.offsetX;\r\n\t\tpos.y += group.offsetY;\r\n\t}\r\n\r\n\tfor (let _item of group.children.items) {\r\n\t\tif (_item === item) {\r\n\t\t\tfound = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (found) {\r\n\t\tlet b = item.getBound();\r\n\t\tpos.x += b.x;\r\n\t\tpos.y += b.y;\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tfor (let _item of group.children.items) {\r\n\t\tif (_item.children == null) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tlet b = _item.getBound();\r\n\t\tpos.x += b.x;\r\n\t\tpos.y += b.y;\r\n\t\tlet result = searchItemInGroup(_item, item);\r\n\t\tif (result != null) {\r\n\t\t\tfound = true;\r\n\t\t\tpos.x += result.x;\r\n\t\t\tpos.y += result.y;\r\n\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tpos.x -= b.x;\r\n\t\t\tpos.y -= b.y;\r\n\t\t}\r\n\t}\r\n\r\n\tif (found) {\r\n\t\treturn pos;\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/helpers/index.js?");

/***/ }),

/***/ "./src/helpers/notification.js":
/*!*************************************!*\
  !*** ./src/helpers/notification.js ***!
  \*************************************/
/*! exports provided: NotificationCenter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotificationCenter\", function() { return NotificationCenter; });\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter2 */ \"./node_modules/eventemitter2/lib/eventemitter2.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nlet NotificationCenter = new eventemitter2__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter2\"]();\r\n\n\n//# sourceURL=webpack:///./src/helpers/notification.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: Scene, Event, Element */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene */ \"./src/scene.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return _scene__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]; });\n\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./src/event.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Event\", function() { return _event__WEBPACK_IMPORTED_MODULE_1__[\"Event\"]; });\n\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./element */ \"./src/element.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return _element__WEBPACK_IMPORTED_MODULE_2__[\"Element\"]; });\n\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/scene.js":
/*!**********************!*\
  !*** ./src/scene.js ***!
  \**********************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./src/event.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/helpers/index.js\");\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./element */ \"./src/element.js\");\n\r\n\r\n\r\n\r\nclass Scene extends _event__WEBPACK_IMPORTED_MODULE_0__[\"EventDelegate\"] {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.backgroundColor = \"white\";\r\n\t\t/** @type {import(\"./event\").Point} */\r\n\t\tthis.downPoint = null;\r\n\t\tthis.enableFinger = false;\r\n\t\tthis.children = new _helpers__WEBPACK_IMPORTED_MODULE_1__[\"ArrayMgr\"]();\r\n\t\t/** @type {Element} */\r\n\t\tthis.mouseTarget = null;\r\n\t\tthis.isDragging = false;\r\n\t}\r\n\r\n\tadd(item) {\r\n\t\tthis.children.add(item);\r\n\t}\r\n\r\n\taddToBottom(item) {\r\n\t\tthis.add(item);\r\n\t\tthis.children.move(item, 0);\r\n\t}\r\n\r\n\trm(item) {\r\n\t\tthis.children.rm(item);\r\n\t}\r\n\r\n\tmoveToFront(item) {\r\n\t\tthis.children.move(item, this.children.items.length - 1);\r\n\t}\r\n\r\n\trender() {\r\n\t\tthis.clear();\r\n\t\tlet rerender = false;\r\n\t\tfor (let i = 0; i < this.children.items.length; i++) {\r\n\t\t\t/** @type {Element} */\r\n\t\t\tlet item = this.children.items[i];\r\n\t\t\titem.updateAnimation();\r\n\t\t\tif (!item.visible) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (item.render(this.ctx)) {\r\n\t\t\t\trerender = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (rerender) {\r\n\t\t\tthis.render();\r\n\t\t}\r\n\t}\r\n\r\n\tclear() {\r\n\t\tthis.ctx.clearRect(0, 0, this.w, this.h);\r\n\t\tthis.ctx.save();\r\n\t\tthis.ctx.fillStyle = this.backgroundColor;\r\n\t\tthis.ctx.fillRect(0, 0, this.w, this.h);\r\n\t\tthis.ctx.restore();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {Element}\r\n\t */\r\n\thitTest(x, y) {\r\n\t\tfor (let i = this.children.items.length - 1; i >= 0; i--) {\r\n\t\t\t/** @type {Element} */\r\n\t\t\tlet item = this.children.items[i];\r\n\t\t\tif (!item.visible) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet ret = item.hitTest(x, y, this.ctx);\r\n\t\t\tif (ret != null) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** @param {Event} e */\r\n\ttriggerMouseDown(e) {\r\n\t\tsuper.triggerMouseDown(e);\r\n\t\t_helpers__WEBPACK_IMPORTED_MODULE_1__[\"NotificationCenter\"].emit(\"start-render\");\r\n\t\tthis.emit(\"mousedown\", e);\r\n\t\tthis.downPoint = { x: e.x, y: e.y };\r\n\t\tthis.mouseTarget = this.hitTest(e.x, e.y);\r\n\t\tif (this.mouseTarget != null) {\r\n\t\t\tthis.mouseTarget.emit(\"mousedown\", e, this.ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @param {Event} e */\r\n\ttriggerMouseUp(e) {\r\n\t\tsuper.triggerMouseUp(e);\r\n\t\tthis.emit(\"mouseup\", e);\r\n\t\tif (this.downPoint == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet item = this.hitTest(e.x, e.y);\r\n\t\tif (item != null) {\r\n\t\t\titem.emit(\"mouseup\", e, this.ctx);\r\n\t\t}\r\n\t\tif (this.mouseTarget != null && this.isDragging) {\r\n\t\t\tlet event = new _event__WEBPACK_IMPORTED_MODULE_0__[\"Event\"](\"mousedragend\", e.x, e.y);\r\n\t\t\tthis.mouseTarget.emit(\"mousedragend\", event, this.ctx);\r\n\t\t\tthis.mouseTarget = null;\r\n\t\t}\r\n\r\n\t\tlet x1 = this.downPoint.x;\r\n\t\tlet y1 = this.downPoint.y;\r\n\t\tlet x2 = e.x;\r\n\t\tlet y2 = e.y;\r\n\t\tif (Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) <= 10) {\r\n\t\t\tlet event = new _event__WEBPACK_IMPORTED_MODULE_0__[\"Event\"](\"click\", e.x, e.y);\r\n\t\t\tif (item != null) {\r\n\t\t\t\titem.emit(\"click\", event, this.ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.isDragging = false;\r\n\t\tthis.downPoint = null;\r\n\t\tthis.render();\r\n\t}\r\n\r\n\t/** @param {Event} e */\r\n\ttriggerMouseMove(e) {\r\n\t\tthis.emit(\"mousemove\", e);\r\n\t\tif (this.downPoint != null) {\r\n\t\t\tthis.isDragging = true;\r\n\t\t}\r\n\t\tlet item = this.hitTest(e.x, e.y);\r\n\t\tif (item != null) {\r\n\t\t\titem.emit(\"mousemove\", e, this.ctx);\r\n\t\t}\r\n\t\tif (this.mouseTarget != null) {\r\n\t\t\tvar event_drag = new _event__WEBPACK_IMPORTED_MODULE_0__[\"Event\"](\"mousedrag\", e.x, e.y);\r\n\t\t\tthis.mouseTarget.emit(\"mousedrag\", event_drag, this.ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @param {Event} e */\r\n\ttriggerMouseWheel(e) {\r\n\t\tthis.emit(\"mousewheel\", e);\r\n\t\tlet item = this.hitTest(e.x, e.y);\r\n\t\tif (item != null) {\r\n\t\t\titem.emit(\"mousewheel\", e, this.ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Element} item\r\n\t * @returns {import(\"./event\").Point}\r\n\t */\r\n\tgetChildPosition(item) {\r\n\t\treturn Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"searchItemInGroup\"])(this, item);\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack:///./src/scene.js?");

/***/ })

/******/ });